<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Hello WebXR!</title>

    
</head>

<body>
    <script type="importmap">
        {
            "imports": {
                "three": "./node_modules/three/build/three.module.js",
                "GLTFLoader":"./node_modules/three/examples/jsm/loaders/GLTFLoader.js",
                "RoomEnvironment": "./node_modules/three/examples/jsm/environments/RoomEnvironment.js",
                "stats": "./node_modules/three/examples/jsm/libs/stats.module.js"
            }
        }
    </script>  

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'GLTFLoader';
        import { RoomEnvironment } from 'RoomEnvironment';
        import Stats from 'stats';
        
        let button=document.createElement("button");
        let buttonText=document.createTextNode("CLICK ME");
	    button.appendChild(buttonText);
        button.addEventListener("click", activateXR);
        document.body.appendChild(button);
       
       
        function createThreeScene() {
            const scene = new THREE.Scene();

            const materials = [
                new THREE.MeshBasicMaterial({ color: 0xff0000 }),
                new THREE.MeshBasicMaterial({ color: 0x0000ff }),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
                new THREE.MeshBasicMaterial({ color: 0xff00ff }),
                new THREE.MeshBasicMaterial({ color: 0x00ffff }),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            ];

            
       
            const box = new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), materials);
            box.position.set(0,-1, -1);
            scene.add(box);
      
            return scene;
        }

        function createThreeRenderer(canvas,gl) {
            const renderer = new THREE.WebGLRenderer({
                alpha: true,
                preserveDrawingBuffer: true,
                canvas: canvas,
                context: gl
            });
            renderer.autoClear = false;
            return renderer;
        }

        function createThreeCamera() {
            // The API directly updates the camera matrices.
            // Disable matrix auto updates so three.js doesn't attempt
            // to handle the matrices independently.
            const camera = new THREE.PerspectiveCamera();
            camera.matrixAutoUpdate = false;
            return camera;
        }

        async function activateXR() {
            
            // Add a canvas element and initialize a WebGL context that is compatible with WebXR.
          
            const canvas = document.createElement("canvas");
            document.body.appendChild(canvas);
            const gl = canvas.getContext("webgl", {
                xrCompatible: true
            });


            const scene = createThreeScene();
            const renderer = createThreeRenderer(canvas,gl);
            const camera = createThreeCamera();

            // Initialize a WebXR session using "immersive-ar".
            const session = await navigator.xr.requestSession("immersive-ar");
            session.updateRenderState({
                baseLayer: new XRWebGLLayer(session, gl)
            });
           
            // A 'local' reference space has a native origin that is located
            // near the viewer's position at the time the session was created.
            const referenceSpace = await session.requestReferenceSpace('local');
           
            // Create a render loop that allows us to draw on the AR view.
            const onXRFrame = (time, frame) => {
                    // Queue up the next draw request.
                    //get device camera stream
                    
                    session.requestAnimationFrame(onXRFrame);

                    // Bind the graphics framebuffer to the baseLayer's framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);
                   
                    // Retrieve the pose of the device.
                    // XRFrame.getViewerPose can return null while the session attempts to establish tracking.
                    const pose = frame.getViewerPose(referenceSpace);
                    if (pose) {
                        // In mobile AR, we only have one view.
                        const view = pose.views[0];

                        const viewport = session.renderState.baseLayer.getViewport(view);
                        renderer.setSize(viewport.width, viewport.height)

                        // Use the view's transform matrix and projection matrix to configure the THREE.camera.
                        camera.matrix.fromArray(view.transform.matrix)
                        camera.projectionMatrix.fromArray(view.projectionMatrix);
                        camera.updateMatrixWorld(true);

                        // Render the scene with THREE.WebGLRenderer.
                        renderer.render(scene, camera)

                    }
                }
               
                //get device camera stream
            session.requestAnimationFrame(onXRFrame);
        }
    </script>
</body>

</html>